<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis的安装及集群配置]]></title>
    <url>%2F2018%2F10%2F27%2FRedis%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。本文主要介绍Redis单机安装及集群配置。 官方下载地址 Redis的安装Redis是c语言开发的，安装需要c语言的编译环境,如果没有gcc需要在线安装: yum install gcc-c++ 安装步骤： 第一步：Redis的源码包上传到Linux 第二步：解压缩到指定文件夹 tar -xvf redis-5.0.0.tar.gz -C /usr/local 第三步：进入redis源码目录，编译 make 第四步：安装: make install PREFIX=/usr/local/redis PREFIX参数指定redis的安装目录,一般软件安装到/usr目录下 Redis的启动： 前端启动：在redis的安装目录下直接启动redis-server [root@localhost bin]# ./redis-server 后台启动： 123把 /usr/local/redis-5.0.0/redis.conf 复制到 /usr/local/redis/bin 目录下 cp redis.conf /usr/local/redis/bin/修改 redis.conf 文件 设置 daemonize yes启动时添加配置文件 ./redis-server redis.conf 关闭：[root@localhost bin]# ./redis-cli shutdown Redis-cli连接 默认连接localhost运行在6379端口的redis服务 [root@localhost bin]# ./redis-cli 自定义连接端口 [root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379 -h：连接的服务器的地址 -p：服务的端口号 远程连接：注释掉 redis.conf 中 bind 127.0.0.1 设置 protected-mode no 重启redis 设置密码：配置文件中添加 requirepass 你的密码 重启redis Redis-cluster集群搭建由于容错机制，Redis集群中至少应该有三个节点。要保证集群的高可用，需要每个节点有一个备份机，因此，Redis集群至少需要6台服务器。 由于个人只有一台服务器，只有搭建伪分布式：一台服务器运行6个redis实例，需要修改Redis的端口号7001-7006 集群搭建环境 使用Ruby脚本搭建集群,需要Ruby的运行环境,安装Ruby yum install ruby yum install rubygems 安装Ruby脚本运行使用的包 https://rubygems.global.ssl.fastly.net/gems/redis-4.0.0.gem 上传所需Ruby库文件redis-4.0.0.gem 安装执行： [root@localhost ~]# gem install redis-4.0.0.gem 该步骤会报错，Centos默认支持ruby到2.0.0，gem 安装redis需要最低是2.2.2。所以需要升级Ruby版本。 安装rvm 123gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\curl -sSL https://get.rvm.io | bash -s stable source /usr/local/rvm/scripts/rvm 查看rvm库中已知的ruby版本 1rvm list known 安装一个ruby版本 1rvm install 2.5 .使用一个ruby版本 1rvm use 2.5.0 卸载一个已知版本 1rvm remove 2.0.0 查看版本 1ruby --version 再安装redis就可以了 1gem install redis-4.0.0.gem 创建 redis-cluster 文件夹，拷贝6个Redis实例到该文件夹中 12345678910111213mkdir -p /usr/local/redis-clustermkdir -p /usr/local/redis-cluster/redis01mkdir -p /usr/local/redis-cluster/redis02mkdir -p /usr/local/redis-cluster/redis03mkdir -p /usr/local/redis-cluster/redis04mkdir -p /usr/local/redis-cluster/redis05mkdir -p /usr/local/redis-cluster/redis06cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis01/cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis02/cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis03/cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis04/cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis05/cp -rf /usr/local/redis/* /usr/local/redis-cluster/redis06/ 搭建Redis集群 每个实例要运行在不同的端口。需要修改redis.conf配置文件：把 cluster-enabled yes 前的注释去掉，并且分别修改端口 port 7001~7006 123port 7001daemonize yescluster-enabled yes 创建开启集群的脚本： 123456789101112131415161718192021[root@localhost redis-cluster]# vim start-all.shcd redis01./bin/redis-server redis.confcd ..cd redis02./bin/redis-server redis.confcd ..cd redis03./bin/redis-server redis.confcd ..cd redis04./bin/redis-server redis.confcd ..cd redis05./bin/redis-server redis.confcd ..cd redis06./bin/redis-server redis.confcd ..//修改脚本文件可执行权限[root@localhost redis-cluster]# chmod u+x start-all.sh 执行脚本启动每个redis实例 1[root@localhost redis-cluster]# ./start-all.sh 如果执行出现No such file or directory错误，解决方法如下： 用vim打开该sh文件 vim start-all.sh 输入 :set ff 回车,显示fileformat=dos,重新设置下文件格式 :set ff=unix 保存退出 :wq 使用ruby脚本搭建集群 123redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1#老版本使用以下命令./redis-trib.rb create --replicas 1 123.207.121.135:7001 123.207.121.135:7002 123.207.121.135:7003 123.207.121.135:7004 123.207.121.135:7005 123.207.121.135:7006 连接集群 [root@localhost redis-cluster]# redis01/bin/redis-cli -p 7001 -c 关闭集群 杀进程：ps -aux|grep redis kill -9 进程ID 踩坑解决问题 重启服务器后重新启动ruby脚本报错 1[ERR] Node 123.207.121.135:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 由于非正常关闭集群，需删除每个节点中的数据文件aof、rdb、nodes.conf，实在不行就只有重装一遍… 强制停止redis快照导致，redis运行用户没有权限写rdb文件或者磁盘空间满了 1MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. 解决办法：修改配置文件 stop-writes-on-bgsave-error no 参考了解Linux Redis集群搭建与集群客户端实现 redis3.0.0 集群安装详细步骤]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置https]]></title>
    <url>%2F2018%2F10%2F26%2FNginx%E9%85%8D%E7%BD%AEhttps%2F</url>
    <content type="text"><![CDATA[今年7月起，Chrome浏览器的地址栏将把所有HTTP标示为不安全网站。HTTPS是HTTP协议的升级版本，更为安全可靠。互联网用户和网站之间的安全连接协议被视为减少用户风险的必要措施，否则用户可能遭受窃听、中间人攻击或数据篡改。因此网站配置HTTPS很有必要，下面针对nginx，谈一下配置HTTPS的步骤。 添加ssl模块nginx配置https，需要添加ssl模块。 查看ngixn版本极其编译参数 1/usr/local/webserver/nginx/sbin/nginx -V 原先的config参数 1configure arguments: --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-pcre 如果存在–with-http_ssl_module说明已添加ssl模块。否则在原先参数的基础上添加–with-http_ssl_module 1./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-pcre --with-http_ssl_module make编译,make后千万别make install，否则就覆盖安装了。make完之后在objs目录下就多了个nginx，这个就是新版本的程序了。 1make 备份原有的nginx配置文件 1cp /usr/local/webserver/nginx/sbin/nginx /usr/local/webserver/nginx/sbin/nginx.bak 将新生成的nginx程序覆盖原有的nginx（这个时候nginx要停止状态） 1cp objs/nginx /usr/local/webserver/nginx/sbin/nginx 测试新的nginx程序是否正确 1/usr/local/webserver/nginx/sbin/nginx -t Nginx 证书部署 获取证书腾讯云或阿里云搜索证书，获取免费证书。下载，将nginx文件夹下的证书上传到服务器。以腾讯云为例，nginx文件夹包括SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key。 证书配置将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/webserver/nginx/key目录下。更新Nginx配置 文件如下： 12345678910111213141516server &#123; listen 443 ssl; #指定ssl监听端口 server_name www.domain.xyz; ssl_certificate /usr/local/webserver/nginx/key/1_www.domain.com_bundle.crt; #指定服务器证书路径 ssl_certificate_key /usr/local/webserver/nginx/key/2_www.domain.com.key; #指定私钥证书路径 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #指定SSL服务器端支持的协议版本 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #指定加密算法 ssl_prefer_server_ciphers on; #在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法 location / &#123; root html; index index.html index.htm; &#125; &#125; 查看配置是否正确： 1/usr/local/webserver/nginx/sbin/nginx -t 正确无误的话，重启nginx： 1/usr/local/webserver/nginx/sbin/nginx -s reload 使用全站加密，http自动跳转https（可选）12345server &#123; listen 80; server_name www.domain.com; #你的域名 rewrite ^(.*) https://$host$1 permanent; #转发http请求到https&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器安装Hexo博客]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[由于之前已经在Windows上有搭建好Hexo项目，并已发布到Github Pages。现在想把项目发布到云服务器上，此文记录整个过程。 环境搭建安装git1yum install git 创建git用户123adduser gitchmod 740 /etc/sudoersvim /etc/sudoers 找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在下面添加一行 1git ALL=(ALL) ALL 保存退出后改回权限 1chmod 400 /etc/sudoers 随后设置Git用户的密码， 12#需要root权限sudo passwd git window生成公钥： 1ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址） 接着出现的一些步骤都可以回车跳过，公钥文件生成位置为C:\Users\a6929.ssh\id_rsa.pub。 切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys文件，并赋予相应的权限 123456su gitmkdir ~/.sshvim ~/.ssh/authorized_keys#将生成的公钥复制粘贴到authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.ssh Windows本地测试连接，是否可以免密登录 1ssh -v git@你的服务器IP 至此，Git用户添加完成 自动化部署服务器上建立git裸库创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权，一定要加 --bare，这样才是一个裸库。 123su gitcd ~git init --bare blog.git 使用 git-hooks 同步网站根目录在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，新建post-receive文件。 1234# 新建文件vim ~/blog.git/hooks/post-receive# 添加以下内容，--work-tree为项目部署的位置，--git-dir为git的位置git --work-tree=/www/public/blog --git-dir=/home/git/blog.git checkout -f 保存后，要赋予这个文件可执行权限 1chmod +x post-receive 创建–work-tree对应的文件夹 123su rootcd ~/..mkdir -p /www/public/blog 修改文件夹权限 123su rootcd ~/..chown -R git:git www #修改文件夹www所属用户为git 配置_config.yml,完成自动化部署12345deploy: type: git repo: git@你的服务器地址:/home/git/blog.git //&lt;repository url&gt; branch: master //这里填写分支 [branch] message: 提交的信息 //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 保存后，测试自动部署到服务器 12hexo cleanhexo g -d]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>博客建站</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX工具部署]]></title>
    <url>%2F2018%2F10%2F25%2FNX%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[在我们开发完整个功能后，需要将工具整合到NX软件中，在工具条、经典工具条、菜单栏等地方直接点击使用。 一、创建工具包最简单的NX应用程序包只包括application和startup两个文件夹。application文件夹放置可执行文件，对NXopen-Java来说，包括.class和.jar。startup文件夹用于放置菜单栏、工具条等配置文件。目录结构如下： 12345678+-- MYTOOLS #顶层文件夹 +-- application #可执行文件夹，名字固定不可变 | -- Test.class | -- Test.jar +-- startup | -- nx_menu.men #菜单栏配置文件 | -- nx_ribbon_toolbar.rtb #新版工具条配置文件 | -- nx_toolbar.tbr #工具栏配置文件 假设我们已经有一个可以完成一定功能的Test.class文件，注意编译时此class文件包名要为空，此时我们需要按照上述目录结构创建对应的文件夹，把我们的class文件放入到application文件夹，在startup文件夹创建各配置文件。 菜单栏配置文件 文件名可随意，后缀为.men，我们暂定为nx_menu.men，从文件名可以看出，是个菜单文件。 1234567891011121314151617VERSION 120EDIT UG_GATEWAY_MAIN_MENUBARAFTER UG_HELP #自定义菜单将显示在帮助之后 CASCADE_BUTTON MYTOOLS_MENU LABEL 二次开发工具 #我们的自定义菜单的显示名称END_OF_AFTERMENU MYTOOLS_MENU #自定义菜单栏开始，要与CASCADE_BUTTON名称一致 BUTTON Test #用于工具条、工具栏绑定改命令 LABEL 方钢属性自动填写 #命令的显示名称 MESSAGE 打开装配体，点击该按钮即可 #鼠标放到命令上弹出的提示 BITMAP properties_object #命令的图标，可自定义，详见西门子文档 ACTIONS Test.class #指定application文件夹下的可行性文件END_OF_MENU 工具栏配置文件 文件名可随意，后缀为.rtb，我们暂定为nx_toolbar.tbr，从文件名可以看出，是个工具栏文件。 12345TITLE 二次开发工具 #工具栏名称VERSION 160DOCK TOPBUTTON Test #与men文件中的BUTTON名对应 新版工具条配置文件 文件名可随意，后缀为.tbr，我们暂定为nx_ribbon_toolbar.rtb，从文件名可以看出，是个工具条文件。 1234567TITLE 二次开发工具 #工具条名称VERSION 170BEGIN_GROUP MYTOOLS_RIBBON_TOOLBAR1 #工具条分组LABEL 二次开发工具 #分组的名称 BUTTON Test #与men文件中的BUTTON名对应END_GROUP 有关工具包的详细信息及各配置文件详情，请参见NX二次开发 二、工具包安装创建完工具包后，就需要将工具包整合到NX中。 将工具包放入NX安装目录将整个文件夹放入到NX安装跟目录下。 配置工具包路径 方法1 找到 “NX安装目录\UGII\menus\custom_dirs.dat” 文件。不同版本位置可能不同，在跟目录下搜索custom_dirs.dat文件名即可找到。在文件最后加入MYTOOLS工具包的全路径，例如我本机路径为C:\Siemens\NX11 \MYTOOLS，每个人NX安装位置不同，路径要做相应的修改。也可引用环境变量获取NX安装路径，这时全路径为$UGII_BASE_DIR\ MYTOOLS ，使用此路径要确认存在名为UGII_BASE_DIR的环境变量，否则不能使用。 方法2 如果方法1中路径含有空格，可能会配置失败。此时需增加环境变量： UGII_GROUP_DIR。 变量名：UGII_GROUP_DIR 变量值：MYTOOLS的全路径 三、重启即可使用工具]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一个博客的搭建过程分为三步： 编写：包含内容的书写与格式的配置 构建：从编写的原始内容生成可发布的最终内容 发布：让待发布的内容对读者可见 依托于博客平台（如博客园、新浪博客等）发布内容的用户只需要关注编写部分，但要搭建一个独立的个人博客则以上三方面都需要关心。幸运的是，现在有大量的工具帮助我们简化这个过程：丰富的 Markup 语言简化了编写；强大的静态站点生成器简化了构建；友好的托管平台简化了发布。 这个博客的诞生也得益于这些工具： 编写：使用 Markdown，内置大量层级、列表、超链接、代码等的简便语法支持 构建：使用 Hexo，几条命令完成生成、预览、发布步骤 发布：使用 GitHub Pages 进行托管，方便又免费 环境准备全局安装hexo 1npm install -g hexo-cli 初始化目录 12hexo init [folder] 指定目录初始化目录hexo init 在当前目录初始化目录 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装 NexT下载主题在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 选择 Pisces Scheme 123#scheme: Musescheme: Mist#scheme: Pisces 本站使用的为Mist主题。 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 设置 菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link || icon name。其中 item name是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567891011121314menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive # about: /about/ || user # search: /search/ || search #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： | 键值 | 设定值 | 显示文本（简体中文） || ———- | ————————- | ——————– || home | home: / | 主页 || archives | archives: /archives | 归档页 || categories | categories: /categories | 分类页 || tags | tags: /tags | 标签页 || about | about: /about | 关于页面 || commonweal | commonweal: /404.html | 公益 404 | 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml（{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设置 侧栏 默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。 12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 设置 头像 编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 头像设置示例 1avatar: http://example.com/avatar.png 设置 作者昵称 编辑 站点配置文件， 设置 author 为你的昵称。 站点描述 编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 设置 RSS NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 具体的链接地址：适用于已经烧制过 Feed 的情形。 添加「标签」页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： 12$ cd your-hexo-site$ hexo new page tags 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 添加「分类」页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： 12$ cd your-hexo-site$ hexo new page categories 编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 设置字体注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是： 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组： 非代码类字体：Fallback 到 &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif 代码类字体： Fallback 到 consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, monospace 另外，每一项都有一个额外的 external 属性，此属性用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 配置示例 12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 设置代码高亮主题更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： 高亮主题设置示例 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 配置示例 12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 配置示例 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 友情链接编辑 主题配置文件 添加： 友情链接配置示例 12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 配置示例 1since: 2013 订阅微信公众号注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 在每篇文章的末尾显示微信公众号二维码，扫一扫，轻松订阅博客。 在微信公众号平台下载您的二维码，并将它存放于博客source/uploads/目录下。 然后编辑 主题配置文件，如下： 配置示例 12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /uploads/wechat-qcode.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 评论系统来必力登陆 来必力 获取你的 LiveRe UID。 编辑 主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 数据统计与分析百度统计 登录 百度统计，定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 内容分享服务百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true。 百度内容分享服务配置示例 1234# 百度分享服务baidushare: type: slide baidushare: true 搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 然后粘贴刚才复制的代码到 1themes/next/layout/_layout.swig 文件中(放在 1&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 的下面)，并把href改为你的github地址 在网站底部加上访问量打开\themes\next\layout\_partials\footer.swig文件，在文件最前面加上以下代码： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码 代码如下： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 实现统计功能实现效果图 具体实现方法在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 部署到github pages在github新建GitHub Pages项目，具体步骤自行百度。 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 编辑 站点配置文件，添加/修改字段 deploy，配置如下： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] //提交信息 部署更新到github 1hexo g -d 访问https://temp.github.io/，temp为你的github用户名，即可查看博客页面。]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>博客建站</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo部署到git报错问题]]></title>
    <url>%2F2018%2F10%2F23%2F%E8%A7%A3%E5%86%B3Hexo%E9%83%A8%E7%BD%B2%E5%88%B0git%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用hexo deploy自动部署到github page的时候出现如下错误： 1fatal: could not read Username for &apos;https://github.com&apos;: Invalid argument 具体解决方法如下： Hexo配置要使用自动部署首先要安装hexo-deployer-git工具： 1npm install hexo-deployer-git --save 配置_config.yml中的deploy： 12345deploy: type: git repo: git@github.com:your_github_user_name/your_github_user_name.github.io.git branch: master message: 提交信息 生成ssh key命令行输入： 1$ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址） 接着出现的一些步骤都可以回车跳过，如下： 配置github账号的ssh key打开id_rsa.pub文件将一整串公钥拷贝下来 进入你的github账户设置，在ssh and GPG keys中新增一个ssh key 验证ssh key： 1ssh -T git@github.com 出现下面的语句说明你的ssh key已经配置好了 1Hi wispyoureyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 初始化本地仓库设置Git的user name和email： 12$ git config --global user.name &quot;wuyanqina&quot;$ git config --global user.email &quot;greenovia@qq.com&quot;（换成你的邮箱地址） 在本地的hexo init生成的文件夹中初始化git仓库： 1$ git init 将本地仓库和远程仓库连接（这一步骤可以不做）： 1$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了 网站部署12hexo cleanhexo g -d 这样你的博客就部署到了page上了~]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用操作]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo前要先安装Node.js和Git，具体安装请各自百度。 Hexo安装npm install -g hexo-cli 建站123hexo init &lt;folder&gt;(不写默认在当前目录)cd &lt;folder&gt;npm install 建站完成后目录结构├── _config.yml(网站的配置信息) ├── package.json(应用程序的信息) ├── scaffolds(模板文件夹) ├── source(资源文件夹) | ├── _drafts(草稿文件夹) | └── _posts(文章文件夹) └── themes(Hexo主题) 新建文章12345hexo new [layout] &lt;title&gt;布局 路径post source/_postspage sourcedraft source/_drafts layout对应于scaffolds文件夹中布局文件;默认取_config.yml中的default_layout Hexo服务器安装1npm install hexo-server --save 启动服务器12hexo server(默认4000)或hexo server -p 5000(指定端口)hexo s --debug 生成静态文件并部署网站hexo generate --deploy 简写：hexo g -d git配置安装 hexo-deployer-git。 $ npm install hexo-deployer-git --save deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] //提交信息 参考资料Hexo中文文档]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>博客建站</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper安装]]></title>
    <url>%2F2017%2F10%2F27%2FZookeeper%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 可以作为集群的管理工具使用。 可以集中管理配置文件。 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 安装 安装环境： Linux：CentOS JDK:1.7以上版本 Zookeeper是Java开发的可以运行在windows、linux环境。需要先安装JDK。 安装步骤： 第一步：安装jdk 第二步：把zookeeper的压缩包上传到linux系统。 第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz 第四步：进入zookeeper-3.4.6目录，创建data文件夹。 第五步：把zoo_sample.cfg改名为zoo.cfg [root@localhost conf]# mv zoo_sample.cfg zoo.cfg 或者直接copy一个出来[root@localhost conf]# cp zoo_sample.cfg zoo.cfg 第六步：修改data属性：dataDir=/root/zookeeper-3.4.6/data 第七步： 启动zookeeper [root@localhost bin]# ./zkServer.sh start 启动zookeeper后台运行并把日志记录在/log/zookeeper.file文件中 [root@localhost bin]# ./zkServer.sh start &gt; ../log/zookeeper.file &amp; 关闭：[root@localhost bin]# ./zkServer.sh stop 查看状态：[root@localhost bin]# ./zkServer.sh status 注意：需要关闭服务器防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装]]></title>
    <url>%2F2017%2F10%2F25%2FNginx%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[网上看别人写的 nginx 服务器配置 ，有的是源码包安装的，有的时 yum 安装的。如果是新手，可能会有疑问，这两种安装方式有什么区别？我应该使用哪种方式？系统里可以两个都安装可以吗？怎么卸载？等等问题，那么在这里，我做下总结，详细介绍下这两种方式。 yum和源码包安装的区别 yum 安装是在线安装，好处是：安装方式简单，不易出错； 源码包 安装是先将 nginx 的源码下载下来，在自己的系统里编译生成可执行文件，然后执行，好处是：因为是在自己的系统上编译的，更符合自己系统的性能，也就是说在自己的系统上执行 nginx 服务性能效率更好。 安装路径不同他们之间最大的区别是 ：安装位置不同。 YUM安装路径 yum 在线安装会将 nginx 的安装文件放在系统的不同位置，可以通过命令 rpm -ql nginx 来查看安装路径，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445➜ ~ rpm -ql nginx/etc/logrotate.d/nginx/etc/nginx/etc/nginx/conf.d/etc/nginx/conf.d/default.conf/etc/nginx/conf.d/ssl.conf/etc/nginx/conf.d/virtual.conf/etc/nginx/fastcgi.conf/etc/nginx/fastcgi.conf.default/etc/nginx/fastcgi_params/etc/nginx/fastcgi_params.default/etc/nginx/koi-utf/etc/nginx/koi-win/etc/nginx/mime.types/etc/nginx/mime.types.default/etc/nginx/nginx.conf/etc/nginx/nginx.conf.default/etc/nginx/scgi_params/etc/nginx/scgi_params.default/etc/nginx/uwsgi_params/etc/nginx/uwsgi_params.default/etc/nginx/win-utf/etc/rc.d/init.d/nginx/etc/sysconfig/nginx/usr/lib/perl5/vendor_perl/auto/nginx/usr/lib/perl5/vendor_perl/auto/nginx/nginx.so/usr/lib/perl5/vendor_perl/nginx.pm/usr/sbin/nginx/usr/share/doc/nginx-1.0.15/usr/share/doc/nginx-1.0.15/CHANGES/usr/share/doc/nginx-1.0.15/LICENSE/usr/share/doc/nginx-1.0.15/README/usr/share/man/man3/nginx.3pm.gz/usr/share/man/man8/nginx.8.gz/usr/share/nginx/html/404.html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html/usr/share/nginx/html/nginx-logo.png/usr/share/nginx/html/poweredby.png/usr/share/vim/vimfiles/ftdetect/nginx.vim/usr/share/vim/vimfiles/indent/nginx.vim/usr/share/vim/vimfiles/syntax/nginx.vim/var/lib/nginx/var/lib/nginx/tmp/var/log/nginx 卸载的时候，只能通过 命令来卸载，因为我们不可能 将这些文件自己手动删除，可以通过命令 rpm -e nginx 来卸载，这个命令一般不会报错，因为 nginx 不与其他的包有依赖关系，如果提示关于 依赖包的问题 ，可以尝试 rpm -e --nodeps nginx 来卸载，这个命令相当于强制卸载，不考虑依赖问题。 源码包安装路径 源码包 安装他的所有文件（包括配置文件，库文件，资源文件等）都在同一个目录下，我们想卸载的时候，直接将这个文件删除就可以，不会有任何垃圾文件存在。通过源码包编译安装的软件，通常都放在 /usr/local/包名 路径下。 启动方式不同 YUM安装启动 yum 安装 nginx，我们可以通过系统服务命令 service 来启动或停止 12345service nginx start #启动 nginx 服务service nginx stop #停止 nginx 服务service nginx restart #重启 nginx 服务 源码包安装启动 源码包 安装 nginx 启动的时候不能使用 service 来启动，需要执行 nginx 安装目录下的 sbin 目录下的 nginx 可执行程序才行，如下（我的 nginx 安装在 /usr/local/webserver/ 目录下） 123/usr/local/webserver/nginx/sbin/nginx #启动 nginx 服务/usr/local/webserver/nginx/sbin/nginx -s stop #停止 nginx 服务/usr/local/webserver/nginx/sbin/nginx -s reload #重启 nginx 服务 或者 直接进入安装目录 ，执行 ./nginx 也可以，这两种方式其实是一样的，. 表示当前目录 12345cd /usr/local/webserver/nginx/sbin ./nginx #启动 nginx 服务./nginx -s stop #停止 nginx 服务./nginx -s reload #停止 nginx 服务注意：在自己的系统中只用选择一种安装方式即可，yum安装的nginx版本可能不是最新的，可以通过源码包安装最新的，但系统中只要一种就可以，如果你想安装两个安装也可以，但是他们监听的端口都是80端口，每次只能启动一个 好，先讲了区别，下面来看一下安装方式 yum安装使用 yum 安装是在线安装，直接使用命令安装即可 1yum install nginx 源码包安装我的系统 centos7.3 64位，首先安装缺少的依赖包： 1yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel 从 http://nginx.org/en/download…. 下载最新稳定版 nginx-1.15.5.tar.gz ，下载的压缩文件 放在任意地方都可以，但是建议放在 /usr/local/src 或者 /root/ 下，/usr/local/src 就是系统专门给用户分配的放 源码的目录，/root/ 是我们默认操作的目录，所以也可以放在这里。我就是下载放在 /root/ 目录下的。 下载可以通过命令获取： 1wget http://nginx.org/download/nginx-1.15.5.tar.gz 解压缩： 1tar -zxvf nginx-1.15.5.tar.gz 解压缩后，可以看到 nginx-1.10.1 目录，然后进入这个目录，在 nginx-1.15.5目录下执行配置 和 make 命令。 123./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module# --prefix指定安装路径，--with安装额外模块make &amp;&amp; make install 常用编译选项说明这段说明，参考自：https://segmentfault.com/a/11… --prefix=PATH ： 指定 nginx 的安装目录。默认 /usr/local/nginx，我的是 /usr/local/webserver/nginx --conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为conf/nginx.conf --user=name ： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。--group=name类似 --with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用--with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（8.39）并解压，指定 pcre 的源码路径 ，比如：--with-pcre=/root/pcre-8.39/。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。 --with-zlib=PATH ： 指定 zlib（版本1.1.3 - 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。 --with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装 --with-http_stub_status_module ： 用来监控 Nginx 的当前状态 --with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址 --add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译） 常用命令123456789/usr/local/webserver/nginx/sbin/nginx #启动 nginx 服务/usr/local/webserver/nginx/sbin/nginx -s stop #停止 nginx 服务/usr/local/webserver/nginx/sbin/nginx -s reload #重启 nginx 服务cd /usr/local/webserver/nginx/sbin #cd到nginx安装目录./nginx #启动 nginx 服务./nginx -s stop #停止 nginx 服务./nginx -s reload #停止 nginx 服务ps -aux | grep nginx #查看进程kill -QUIT 2072 #从容停止]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运行jar包]]></title>
    <url>%2F2017%2F09%2F27%2FLinux%E8%BF%90%E8%A1%8Cjar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文主要阐述CentOS环境下如何运行以及停止jar 运行jar 方式1 1java -jar XXX.jar 特点：当前ssh窗口被锁定，按CTRL + C，或直接关闭窗口，程序退出。 那如何让窗口不锁定？ 方式2 1java -jar XXX.jar &amp; #&amp;代表在后台运行 特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。 继续改进，如何让窗口关闭时，程序仍然运行？ 方式3 1nohup java -jar XXX.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行。 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 方式4 1nohup java -jar XXX.jar &gt;temp.txt &amp; 自定义输出文件。 停止jar 方式1 查看所有后台执行的作业，每个作业前面都有个编号。 1jobs fg+编号，将某个作业调回前台控制，Ctrl+c中断程序运行或者使用以下命令。 1kill %num #num为编号 方式2 查看与java相关的进程 1ps -ef | grep java 每一行从前往后依次显示：UID PID PPID C STIME TTY TIME CMD各相关信息的意义： 12345678UID： 程序被该 UID 所拥有PID ：就是这个程序的 IDPPID ：则是其上级父程序的IDC： CPU 使用的资源百分比STIME ：系统启动时间TTY： 登入者的终端机位置TIME： 使用掉的CPU时间CMD ：下达的指令 使用kill命令停止进程 1kill &lt;pid&gt; #pid为进程对应的pid]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装jre]]></title>
    <url>%2F2017%2F09%2F26%2FCentOS%E5%AE%89%E8%A3%85jre%2F</url>
    <content type="text"><![CDATA[本文主要阐述了CentOS环境下如何通过源码安装jre 源码安装创建文件夹12mkdir /usr/javacd /usr/java 下载文件官网下载文件，通过ftp工具（如editplus，xftp等）上传的上面创建的文件夹中。 解压1tar -zxvf jre名称 设置环境变量1vim /etc/profile 在最后加入以下内容 1234#set java environmentJAVA_HOME=/usr/java/jre1.8.0_192PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME PATH 让修改生效1source /etc/profile 查看是否安装成功1java -version]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NXOpen包装ufunc]]></title>
    <url>%2F2017%2F08%2F05%2FNXOpen%E5%8C%85%E8%A3%85ufunc%2F</url>
    <content type="text"><![CDATA[NXOpen是一个应用程序编程接口（API）工具包的集合，它允许通过开放的体系结构灵活地集成定制NX应用程序。其目的是使复杂和重复的任务自动化。此外，还允许集成不同的应用程序，以及第三方和NX应用程序，在不同的计算机平台上共享数据，从不同的位置使用异构网络，甚至跨Internet。NXOpen API提供了一个开放的体系结构，可以由第三方、客户和内部用户利用它们来创建和集成定制软件应用程序。NXOpen主要是指NX的common API。 ufunc(Open C)发展了很多年，包含5000多个函数，功能覆盖方方面面。Common API通过生成.NET、Java和Python的包装类来保证能使用这些函数。 一些OpenC函数没有包装类，详情参见列表Non-NXOpen functionsOpenC模块及函数映射到NXOpen详见命名约定 Common API将对象表示为典型的面向对象对象，而OpenC则将它们表示为标记(Tag)。下面的示例说明如何在对象和标记之间切换。 在使用包装类前要理解一些简单的概念： 名称空间和模块结构.NET NXOpen 包装类定义在NXOpen.UF命名空间。Java包装类在NXOpenUF.jar中，定义在nxopen.uf包。Python包装类包含在NXOpen_UF.pvd扩展模块，定义在NXOpen.UF模块。 UFSession获得包装类之前你首先要获得UFSession的实例。包装类(与ufunc模块对应)定义在UFSession的方法中。例如：UFSession的curve()方法返回一个UFCurve类的实例。 TaggedObjectManager and NXObjectManagerTaggedObjectManager是定义在nxopen包里面的一个NXOpen Java接口。使用该类的get方法获取与标签对应的NXOpen Tag对象。.NET、Python对应的类分别为TaggedObjectManager、NXObjectManager。 Tag属性所有的NXOpen标签对象在.NET和Python中都有一个Tag属性，在Java和c++中有一个tag()方法。 包装类-具体实例1.NXopen .NET下面的例子使用ufunc API生成一个圆弧并用NXOpen.NET API查询圆弧数据：1234567891011121314151617Dim theSession As Session = Session.GetSession() Dim theUFSession As UFSession = UFSession.GetUFSession() &apos; Create an ARC using the Open API Tag arc;Dim arc_coords As UFCurve.Arcarc_coords.radius = 1.0arc_coords.arc_center = New Double()&#123;1.0, 1.0, 0.0&#125;arc_coords.start_angle = 0.0arc_coords.end_angle = Math.PIarc_coords.matrix_tag = theSession.Parts.Display.WCS.CoordinateSystem.Orientation.TagtheUFSession.Curve.CreateArc( arc_coords, arc)&apos; Get the Arc Object to use with NX Open NXOpen.Arc nxArc= CType(NXOpen.Utilities.NXObjectManager.Get(arc), NXOpen.Arc)&apos;Get the Arc parameters using NX Open APIsDim start_angle As Double = nxArc.StartAngle Dim end_angle As Double = nxArc.EndAngle Dim arc_center As NXOpen.Point3d = nxArc.CenterPoint 2.NXOpen JAVA下面的例子使用ufunc API生成一个圆弧并用NXOpenJava API查询圆弧数据：12345678910111213141516171819202122Session theSession = (Session)SessionFactory.get(&quot;Session&quot;);UFSession theUFSession = (UFSession)SessionFactory.get(&quot;UFSession&quot;);/* Create Arc using Open C API wrapper */UFCurve ufCurve = theUFSession.curve();UFCurve.Arc ufArc = new UFCurve.Arc();UFCsys ufCsys = theUFSession.csys();/* Fill out the data structure */ufArc.startAngle = 0.0;ufArc.endAngle = 3.0;ufArc.arcCenter=new double[3];ufArc.arcCenter[0] = 0.0;ufArc.arcCenter[1] = 0.0;ufArc.arcCenter[2] = 1.0;ufArc.radius = 2.0;/* Create Arc */Tag wcsData = ufCsys.askWcs();ufArc.matrixTag = ufCsys.askMatrixOfObject(wcsData);Tag arcTag = ufCurve.createArc(ufArc);/* Get the Arc Object to use with NX Open*/Arc arc = (Arc)theSession.taggedObjectManager().get(arc2Tag);/* Get arc parameters using NX Open Java APIs */double start_angle = arc.startAngle(); 3.NXOpen Python下面的例子使用ufunc API生成一个圆弧并用NXOpenPython API查询圆弧数据：1234567891011121314151617theSession = NXOpen.Session.GetSession() theUFSession = NXOpen.UF.UFSession.GetUFSession() # Create an ARC using the Open API arc_coords = NXOpen.UF.Curve.Arc()arc_coords.Radius = 1.0arc_coords.ArcCenter = [1.0, 1.0, 0.0]arc_coords.StartAngle = 0.0arc_coords.EndAngle = math.piarc_coords.MatrixTag = theSession.Parts.Display.WCS.CoordinateSystem.Orientation.Tagarc_tag = theUFSession.Curve.CreateArc( arc_coords)# Get the Arc Object to use with NX Open nxArc = NXOpen.TaggedObjectManager.GetTaggedObject(arc_tag)# Get the Arc parameters using NX Open APIsstart_angle = nxArc.StartAngle end_angle = nxArc.EndAngle arc_center = nxArc.CenterPoint 参考资料包装类官方文档]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NXOpen应用程序目录结构]]></title>
    <url>%2F2017%2F08%2F03%2FNXOpen%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[对于环境变量指定的任何根目录，NX寻找以下五个子目录：startup, application, udo, udf, and dfa。 注意：子目录下的文件名不能跟根目录下任何目录名相同(包含根目录下的所有子目录，不管层级)。否则程序执行会报错。 每个子目录使用说明如下： 子目录 使用 startup 放置自定义菜单文件、对话框和可执行文件。通常用于一般功能的应用程序 application 放置与NX菜单关联的自定义菜单项和可执行文件 udo 放置NX初始化时用于管理自定义对象所注册的方法 dfa 放置与该应用程序关联的类、函数和方法的KF ASCII定义文件。此目录不显示在DFA管理器或KF首选项中 udf 用户的自定义特性 有关使用环境变量和客户默认配置KF应用程序的信息。请参见知识融合在线帮助中的默认值和变量概述。 当启动NX时，它会自动加载startup和udo目录下的库和菜单文件。当NX加载每个共享库时，它立即执行标准入口点（参见入口点）。然后应用程序可以初始化任何事件。 为了让NX更快地启动，可以将程序放在application目录中，而不是startup目录。当您选择此策略时，当用户选择关联菜单按钮时，NX加载库，而不是在启动时加载。这个策略不能用于管理UDO。UDO程序必须放在startup，以确保NX能加载到事件。 包含在这些子目录的动态加载共享库必须包含操作系统的正确文件扩展名。如果没有使用正确的扩展，则NX将无法找到目标文件。NX将显示一个错误，指出应用程序没有被正确注册。 参考资料NXopen应用程序目录结构]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX新建工具条]]></title>
    <url>%2F2017%2F08%2F01%2FNX%E6%96%B0%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[NX工具条包括经典工具条和新版本的功能区。两种对应于不同的文件。经典工具条是以.tbr结尾的文件，功能区为.rtb结尾。 工具条文件需放在应用程序startup文件夹，以确保NX启动时能找到该文件。整个应用要想被NX找到需配置环境变量UGII_USER_DIR=&lt;根路径&gt;。或在&lt;NX安装目录&gt;\UGII\menus\custom_dirs.dat文件中配置根路径。 经典工具条1234567891011121314TITLE 金旅二次开发工具VERSION 160DOCK TOP BUTTON MENU1 BUTTON MENU2 BUTTON MENU3 SEPARATOR BUTTON MENU21 BUTTON MENU22 SEPARATOR BUTTON TC1 SEPARATOR BUTTON DRAFT1 效果如下： TITLE顾名思义为标题 VERSION，版本 DOCK，工具栏的停靠位置。可去TOP、BOTTOM、LEFT、RIGHT等 BUTTON后为men文件中定义的菜单项名称。如果菜单项有定义图标，则显示图标。否则显示菜单项文字。 SEPARATOR，分割线 新版本功能区1234567891011121314151617181920212223242526272829TITLE 金旅二次开发工具VERSION 170BEGIN_GROUP JL_MAIN1LABEL 金旅二次开发工具 BUTTON MENU1 BUTTON MENU2 BUTTON MENU3END_GROUPBEGIN_GROUP JL_MAIN2LABEL 自动指引 BUTTON MENU21 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXT BUTTON MENU22 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUPBEGIN_GROUP JL_TCLABEL TC相关 BUTTON TC1 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUPBEGIN_GROUP JL_DRAFTLABEL 制图相关 BUTTON DRAFT1 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUP 效果如下： TITLE，标题 VERSION，版本 BEGIN_GROUP，END_GROUP定义一个组。如上图有”金旅二次开发工具”、”自动指引”、”TC相关”、”制图相关”四个组。 LABEL，组名称 BUTTON，men文件中菜单项的名称 RIBBON_STYLE，按钮的样式 参考资料细节请参考菜单及工具条]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX新建菜单栏]]></title>
    <url>%2F2017%2F07%2F30%2FNX%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[Menuscript语言可将新菜单项添加到NX。Menuscript命令存在于.men后缀结尾的文件中。无论使用哪种语言，菜单文件都是相同的。 要添加一个新的菜单项，以下描述菜单文件的基本命令：1234567VERSION 120 EDIT UG_GATEWAY_MAIN_MENUBAR MENU &lt;独一无二的文本，用于识别现有的或新的菜单&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; &lt;...&gt; END_OF_MENU 每个菜单项可以通过下面的命令定义：12345BUTTON &lt;所有菜单项独一无二的文本&gt; LABEL &lt;菜单展示的文本&gt; MESSAGE &lt;鼠标放在按钮上弹出的提示&gt;BITMAP &lt;按钮图标名称&gt;ACTIONS &lt;程序的名称&gt; 任何程序都可以链接到菜单文件中的一个按钮。可以是与NX无关的浏览器，或是传统的NX程序。men文件一定要放在startup目录下 运行与NX无关的程序下面简单的men文件在打开菜单后面注册一个按钮，通过IE访问西门子官网。1234567VERSION 120 EDIT UG_GATEWAY_MAIN_MENUBAR AFTER UG_FILE_OPEN BUTTON SAMPLE_GO_TO_SIEMENS LABEL Go to Siemens.com ACTIONS &quot;start iexplore http://www.siemens.com&quot; END_OF_AFTER 运行与CommonAPI程序如果想从按钮运行一个通用的API程序，必须要把编译后的程序放置在application目录下。在men文件中的ACTIONS后加上文件名。对于C、C++、C#或VB程序，不需带后缀。对于java程序，需带后缀让NX知道是.class或.jar文件。12345678910111213141516171819202122232425VERSION 120EDIT UG_GATEWAY_MAIN_MENUBARAFTER UG_HELP CASCADE_BUTTON MY_MENU LABEL 二次开发工具END_OF_AFTERMENU MY_MENU BUTTON MENU1 LABEL 属性快捷填写 MESSAGE 快速填写属性 BITMAP properties_object ACTIONS FillInProperty.jar SEPARATOR BUTTON MENU2 LABEL 自动分层 MESSAGE 将显示的实体、草图、曲线点、基准、片体移动到指定层，2、3层对象忽略，除了1（有用实体）、2（有用片体）、3（有用控制曲线）层打开，其他隐藏 BITMAP layer_move_to ACTIONS Layout.classEND_OF_MENU 参考资料细节请参考菜单及工具条]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[官方例子：怎样创建一个NXOpen程序]]></title>
    <url>%2F2017%2F07%2F27%2F%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AANXOpen%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[你可以为许多不同的任务和函数创建一个NX打开的程序，比如在NX中操作的一个从命令行启动的函数，它可以被添加到菜单列表或其他NX命令结构中，或者是一个新对话框。 在这个例子中，我们创建一个对话框，选择面然后改变面颜色。 主要步骤如下:12345创建一个对话框从对话框中生成代码添加代码到生成的源文件中设置目录结构测试 在这个例子中，我们修改initialize(初始化)和apply(应用)回调函数。对于更复杂的对话框，你可以将代码添加到update(更新)回调函数来处理不断的变化。有关创建对话框的其他信息，参见UIStyler块介绍。有关使用静态API属性的信息，参见块属性的静态API 一、创建对话框1.打开NX 2.打开建模应用模块。可以通过打开一个零件或新建一个模型进入 3.搜索“块 UI 样式编辑器”进入UI编辑器(注意搜索要带空格) 4.在块目录组中，打开‘选择’目录。点击‘选择对象’，创建并显示“无标题”对话框 5.打开‘基本’目录，点击‘对象颜色拾取器’ 6.通过修改对话框中的属性来更改对话框标签。 在块选项卡，group块树中选择selection0。在属性选项卡，选择LabelString。双击修改为”选择面” 选择SelectMode，右击将值从Single改Multiple 在树列表中选择colorPicker0。在属性选项卡，选择Label。双击修改为”选择颜色” 在树列表中选择Group。在属性选项卡，选择Label。双击修改为”面” 在树列表中选择Dialog。在属性选项卡，选择Label。双击修改为”改变面的颜色” 二、从对话框生成代码1.在设计对话框选择”代码生成”块，右击”语言”，选择Java 2.右击”生成附注”，选择True 3.右击”特定于块的代码”，选择True 4.确保”用户出口”为True。 5.确保”更新”、”确定”、”显示的对话框”为True 6.选择保存(ctrl+s)，生成一个.dlx文件,一个.java文件 7.点击”退出块 UI 样式编辑器” 三、向生成代码中添加代码1.打开.java 文件 2.添加”添加以下代码”、”添加代码结束”中间代码1234567891011121314151617public void initialize() throws NXException, RemoteException&#123; try &#123; group0 = (nxopen.blockstyler.Group)theDialog.topBlock().findBlock(&quot;group0&quot;); selection0 = (nxopen.blockstyler.SelectObject)theDialog.topBlock().findBlock(&quot;selection0&quot;); colorPicker0 = (nxopen.blockstyler.ObjectColorPicker)theDialog.topBlock().findBlock(&quot;colorPicker0&quot;); //添加以下代码--------------- selection0.addFilter(nxopen.blockstyler.SelectObject.FilterType.FACES);//过滤器，只能选择面 //添加代码结束--------------- &#125; catch(Exception ex) &#123; //---- Enter your exception handling code here ----- theUI.nxmessageBox().show(&quot;Block Styler&quot;, nxopen.NXMessageBox.DialogType.ERROR, ex.getMessage()); &#125;&#125; 12345678910111213141516171819202122232425262728293031public int apply() throws NXException, RemoteException&#123; int errorCode = 0; try &#123; //---- Enter your callback code here ----- //添加以下代码--------------- //获取DisplayModification对象 TaggedObject[] selObjs = selection0.getSelectedObjects(); DisplayModification dispMod = theSession.displayManager().newDisplayModification(); //获取选择的颜色 int[] colors = colorPicker0.getValue(); dispMod.setNewColor(colors[0]); //获取选择的面 List&lt;DisplayableObject&gt; dispObjs = new ArrayList&lt;DisplayableObject&gt;(); for (TaggedObject taggedObject : selObjs) &#123; dispObjs.add((DisplayableObject) taggedObject); &#125; //应用 dispMod.apply((DisplayableObject[]) dispObjs.toArray()); dispMod.dispose(); //添加代码结束--------------- &#125; catch(Exception ex) &#123; //---- Enter your exception handling code here ----- errorCode = 1; theUI.nxmessageBox().show(&quot;Block Styler&quot;, nxopen.NXMessageBox.DialogType.ERROR, ex.getMessage()); &#125; return errorCode;&#125; 四、设置目录结构1.设置以下环境变量作为应用程序的根目录。 UGII_USER_DIR(或UGII_GROUP_DIR)=&lt;full directory path&gt; 注意：此环境变量仅适用于单个应用程序。有关为单个或多个应用程序设置根目录的附加信息，请参见环境变量。 2.在上面指定的根目录下创建应用程序的目录结构。请参见应用程序目录结构，看看如何设置目录结构以及NX如何在启动时加载自定义文件和应用程序。 3.复制.class、.dlx文件到上一步中创建的应用程序目录 五、测试1.打开模型应用模块(打开或新建一个模型) 2.点击 文件–执行–NXOpen。快捷键Ctrl+U。选择.class文件运行 六、实例文件对话框文件：changeFaceColor.dlx源码：changeFaceColor.java]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈NX二次开发可用的开发工具包]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%B5%85%E8%B0%88NX%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%8F%AF%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[NX和其他西门子PLM软件产品提供了许多软件工具包。NXOpen是指提供直接与NX对象模型一起工作的过程API。每个API支持特定的编程语言。一组相对较新的语言都共享一个共同的对象模型，称为通用的API(Common API)。其他三种API已经存在多年，统称为遗留或经典API(Classic APIs)。 一、Common API这个NX架构向NX开发人员提供一个公共对象的特性和功能。使用这个公共对象模型，可以自动生成多语言绑定。这意味着来自通用api的所有语言都具有相同的对象集、对象属性和方法。此外，对于所有公共API，类层次结构是相同的。 这种体系结构比传统api使用的体系结构有许多优势。例如: 所有通用api语言在NX功能方面都是平等的。这意味着您可以自由地选择适合您特定需求的实现语言，而不必担心缺少的功能。 在NX中引入新的功能和自动化功能；交互方式和编程方式之间的功能不再延迟。 现在您可以访问NX开发人员使用的同一个对象模型。 通用api可以使用以下语言绑定： 1.NX Open for .NET - 这个API使用微软的.NET框架。这个API可以使用.NET兼容的语言创建任何自动化程序，包括Visual Basic .NET和C #。用户可以充分利用.NET框架提供的所有好处，包括本地Windows对话框开发工具和VisualStudio集成开发环境（IDE）的所有功能。如果Windows是你选择的平台，这个API是理想的。 2.NX Open for Java - 这个API使用甲骨文的java平台。java提供了许多好处，包括平台独立性和巨大的现有类库。java抽象窗口工具包（AWT）和Swing提供了工具构建平台无关的对话框。java远程方法调用（RMI）方法提供的工具来构建基于客户机/服务器应用程序。此外，还可以提供诸如Eclipse这样的免费开发环境。如果正在开发多个平台客户机/服务器应用程序，则此API是理想的。 3.NX Open for C++ - 这个API提供了NX的C++接口。这个新的C++库兼容Open C and Open C++ APIs。如果你需要提高现有的C / C++应用程序，这个API是理想的。 4.NX Open for Python - 这个API提供了一个NX的Python接口。Python是一种脚本语言，它使用现代编程范式，如面向对象编程和反射。它使用较简介的语法，并有一些用于科学和数值编程的扩展包。没有提供Python的远程API。 二、Journaling(录制功能)虽然Journaling不是一个工具包，在这里介绍是因为它可以用来记录自动化解决方案或使用大型应用程序生成代码。 Journaling是一种快速的自动化工具，记录、编辑和回放，交互式NX。它从通用API构建，在NX的交互式会话生成一个脚本文件，它可以在稍后时间重放。这些Journaling可以通过简单的编程结构和用户界面组件进行编辑和增强，以快速生成定制程序。 虽然日志重播目前仅限于# Python，C，Visual Basic .NET，用户可以选择记录在任何常用的API的语言。这种技术可以用来生成示例代码，然后可以在较大的应用程序中使用。 三、Classic APIs在NX采用通用api之前，开发了这三个api。这些API仍然可用，但不再对它们增强。 1.Open C - Open C API(ufunc)是NX的直接编程接口，它允许用户使用流行的C编程语言创建自定义应用程序。NX开发人员、客户和合作伙伴已经使用它来生成独特的应用程序来增强NX或充当完全独立的实用程序。Open C还提供了一个完全可扩展的数据模型，允许客户定义类似于标准NX对象的新类型的对象，并持久保存在NX部分文件中。Open C API已经发展了很多年，由5000多个函数组成。这些函数统称为用户函数。这个API通常被称为ufunc。开放的C函数通常有命名约定：UF__。例如，uf_modl_create_plane()。考虑到这个API的历史，它提供了广泛的功能。为了确保新的应用程序都可以访问这些功能.net，java，Python提供了包装器。 2.Open C++ - 这个API为NX提供了第一个面向对象的接口。用C++写的，这个API充分利用了面向对象的特征包括继承、封装和多态性。OpenC++提供完整的访问的类层次结构，使客户能够重写方法，派生自己的类，并创建全新NX的持久对象。OpenC++完全兼容Open C API。 3.NX Open GRIP - GRIP(图形交互编程)是一种用于自动化CAD/CAM任务的中间脚本语言。用户可以创建应用程序来实现数控操作，创建几何和绘图对象，控制系统参数，执行文件管理功能和修改现有的几何图形。 四、KF(Knowledge Fusion)Knowledge Fusion (KF) - 此API是嵌入在NX中的解释型、面向对象的语言。KF允许您通过创建规则，将工程知识添加到任务中，这些规则是语言的基本组成部分。语言是声明性的，而不是过程性的，这意味着规则在需要时执行，不管顺序如何。知识融合规则引擎根据规则之间的依赖关系确定正确的规则触发序列。此外，该语言还具有访问外部知识库（如数据库或电子表格）的能力，以及与其他应用程序（如分析和优化包）的接口。此API非常适合于需要参与模型更新的关联、持久对象的应用程序。有关更多信息，请参见知识融合和知识融合帮助和最佳实践。 五、其他的NX开发工具包除了上面提供的NX开放API工具包之外，西门子PLM软件还提供了以下的NX自动化工具。本文档将大致介绍NX开放的这些工具包。每个工具箱的完整信息可以在各自的用户指南中找到。 1.Block Styler (UI Styler) - 这是一个视觉用户界面生成器，可以交互设计的便携式NX风格对话框。它由NX开发人员在内部使用，外部由用户和第三方开发人员使用。这提供了一个运行在NX内的对话框生成器。由生成器产生的对话框定义文件是在运行NX会话期间自动加载，并提供程序处理用户交互的必要事件回调。更多信息见BlockStyler用户指南。 2.MenuScript - 此工具允许终端用户和第三方开发人员创建和编辑NX菜单。MenuScript是一个文本语言，可以用来自定义NX菜单项,用于从NX启动应用程序。菜单文件支持定制的主菜单栏和快速查看弹出菜单。标准的NX菜单可以定制,以满足特定的工作流程,可添加Block Styler创建对话框到新的菜单项。更多信息请查看菜单用户指南。 3.Open User Interface Styler (UI Styler) - UI Styler是可视化的用户界面生成器，用于维护Block Styler之前创建的基于UI Styler的对话框。新的对话框，应使用Block Styler.定义。更多信息见UI Styler用户指南。 六、其他的西门子PLM软件工具包西门子PLM软件提供了许多其他自动化和系统集成工具包。这里提到了两个工具包，因为它们与NX一起使用的频率比较高。这些工具包的使用超出了本手册的范围。有关更多信息，请参见它们各自的用户指南，它们不是NX帮助库的一部分。 1.Parasolid - Parasolid是世界领先的生产验证的几何建模软件，允许用户模拟行业最复杂的部件和组件。作为在不同计算机上的几何引擎的辅助设计、制造和工程（CAD/CAM/CAE）应用，Parasolid已在全球产品设计建立一个行业标准。Parasolid是用NX实体建模内核。 2.Teamcenter Engineering Integration Tool Kit (ITK) - 这个API提供用于定制Teamcenter支持组织的特定的数据管理功能和公用事业的需求。Teamcenter是客户端-服务器架构为基础的系统。可以对服务器和客户机部分进行定制。如果必须直接与Teamcenter自动化保存或检索产品数据通过NX和其他第三方应用程序生成过程中的应用，那么这个API是理想的。 参考资料官方例子链接：UFUN中文API 密码：pjc1链接：NXJavaAPI离线文档 密码：494sJava官方API 推荐网站nxjournaling]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX二次开发Eclipse环境搭建]]></title>
    <url>%2F2017%2F07%2F20%2FNX%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91Eclipse%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器；本文章适用于使用Java进行NX二次开发。其他NXopen支持的语言请参考官方文档。 一、开发环境的搭建NXjar包存放目录：%NX安装目录%\NXBIN。NX提供的所有jar包，导入NXOpen开头的jar到JavaProject即可 二、调试环境的搭建使用Eclipse调试Java程序： 1.在NX中，选择 文件→执行 →替代Java参数 2.在替代Java参数对话框, UGII_JVM_OPTIONS 输入框中输入: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8888 (可选) 在 UGII_JVM_CLASSPATH 对话框中, 填入任意额外的Java classpath地址 3.你不需要在这里写入NXopen jar的classpath，因为他们会被NX自动加载 4.(可选) 在 UGII_JVM_LIBRARY_DIR 对话框, 写入你的64位Java的JVM地址。例如: %jre安装目录%\bin\server 5.点击 确定 6.在Eclipse Package Explorer，右键项目，Debug As →Debug Configurations 7.创建一个Remote Java Application，使用和上面相同的端口 8.你需要在NX上运行Java程序。Eclipse会在指定断点暂停 9.其他语言调试环境搭建敬请参见NX其他语言调试环境搭建 THE END.]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
