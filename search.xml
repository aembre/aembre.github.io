<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NX工具部署]]></title>
    <url>%2F2018%2F10%2F25%2FNX%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[在我们开发完整个功能后，需要将工具整合到NX软件中，在工具条、经典工具条、菜单栏等地方直接点击使用。 一、创建工具包最简单的NX应用程序包只包括application和startup两个文件夹。application文件夹放置可执行文件，对NXopen-Java来说，包括.class和.jar。startup文件夹用于放置菜单栏、工具条等配置文件。目录结构如下： 12345678+-- MYTOOLS #顶层文件夹 +-- application #可执行文件夹，名字固定不可变 | -- Test.class | -- Test.jar +-- startup | -- nx_menu.men #菜单栏配置文件 | -- nx_ribbon_toolbar.rtb #新版工具条配置文件 | -- nx_toolbar.tbr #工具栏配置文件 假设我们已经有一个可以完成一定功能的Test.class文件，注意编译时此class文件包名要为空，此时我们需要按照上述目录结构创建对应的文件夹，把我们的class文件放入到application文件夹，在startup文件夹创建各配置文件。 菜单栏配置文件 文件名可随意，后缀为.men，我们暂定为nx_menu.men，从文件名可以看出，是个菜单文件。 1234567891011121314151617VERSION 120EDIT UG_GATEWAY_MAIN_MENUBARAFTER UG_HELP #自定义菜单将显示在帮助之后 CASCADE_BUTTON MYTOOLS_MENU LABEL 二次开发工具 #我们的自定义菜单的显示名称END_OF_AFTERMENU MYTOOLS_MENU #自定义菜单栏开始，要与CASCADE_BUTTON名称一致 BUTTON Test #用于工具条、工具栏绑定改命令 LABEL 方钢属性自动填写 #命令的显示名称 MESSAGE 打开装配体，点击该按钮即可 #鼠标放到命令上弹出的提示 BITMAP properties_object #命令的图标，可自定义，详见西门子文档 ACTIONS Test.class #指定application文件夹下的可行性文件END_OF_MENU 工具栏配置文件 文件名可随意，后缀为.rtb，我们暂定为nx_toolbar.tbr，从文件名可以看出，是个工具栏文件。 12345TITLE 二次开发工具 #工具栏名称VERSION 160DOCK TOPBUTTON Test #与men文件中的BUTTON名对应 新版工具条配置文件 文件名可随意，后缀为.tbr，我们暂定为nx_ribbon_toolbar.rtb，从文件名可以看出，是个工具条文件。 1234567TITLE 二次开发工具 #工具条名称VERSION 170BEGIN_GROUP MYTOOLS_RIBBON_TOOLBAR1 #工具条分组LABEL 二次开发工具 #分组的名称 BUTTON Test #与men文件中的BUTTON名对应END_GROUP 有关工具包的详细信息及各配置文件详情，请参见NX二次开发 二、工具包安装创建完工具包后，就需要将工具包整合到NX中。 将工具包放入NX安装目录将整个文件夹放入到NX安装跟目录下。 配置工具包路径 方法1 找到 “NX安装目录\UGII\menus\custom_dirs.dat” 文件。不同版本位置可能不同，在跟目录下搜索custom_dirs.dat文件名即可找到。在文件最后加入MYTOOLS工具包的全路径，例如我本机路径为C:\Siemens\NX11 \MYTOOLS，每个人NX安装位置不同，路径要做相应的修改。也可引用环境变量获取NX安装路径，这时全路径为$UGII_BASE_DIR\ MYTOOLS ，使用此路径要确认存在名为UGII_BASE_DIR的环境变量，否则不能使用。 方法2 如果方法1中路径含有空格，可能会配置失败。此时需增加环境变量： UGII_GROUP_DIR。 变量名：UGII_GROUP_DIR 变量值：MYTOOLS的全路径 三、重启即可使用工具]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一个博客的搭建过程分为三步： 编写：包含内容的书写与格式的配置 构建：从编写的原始内容生成可发布的最终内容 发布：让待发布的内容对读者可见 依托于博客平台（如博客园、新浪博客等）发布内容的用户只需要关注编写部分，但要搭建一个独立的个人博客则以上三方面都需要关心。幸运的是，现在有大量的工具帮助我们简化这个过程：丰富的 Markup 语言简化了编写；强大的静态站点生成器简化了构建；友好的托管平台简化了发布。 这个博客的诞生也得益于这些工具： 编写：使用 Markdown，内置大量层级、列表、超链接、代码等的简便语法支持 构建：使用 Hexo，几条命令完成生成、预览、发布步骤 发布：使用 GitHub Pages 进行托管，方便又免费 环境准备全局安装hexo 1npm install -g hexo-cli 初始化目录 12hexo init [folder] 指定目录初始化目录hexo init 在当前目录初始化目录 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装 NexT下载主题在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 选择 Pisces Scheme 123#scheme: Musescheme: Mist#scheme: Pisces 本站使用的为Mist主题。 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 设置 菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link || icon name。其中 item name是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567891011121314menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive # about: /about/ || user # search: /search/ || search #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： | 键值 | 设定值 | 显示文本（简体中文） || ———- | ————————- | ——————– || home | home: / | 主页 || archives | archives: /archives | 归档页 || categories | categories: /categories | 分类页 || tags | tags: /tags | 标签页 || about | about: /about | 关于页面 || commonweal | commonweal: /404.html | 公益 404 | 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml（{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设置 侧栏 默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。 12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 设置 头像 编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 头像设置示例 1avatar: http://example.com/avatar.png 设置 作者昵称 编辑 站点配置文件， 设置 author 为你的昵称。 站点描述 编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 设置 RSS NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 具体的链接地址：适用于已经烧制过 Feed 的情形。 添加「标签」页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： 12$ cd your-hexo-site$ hexo new page tags 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 添加「分类」页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： 12$ cd your-hexo-site$ hexo new page categories 编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 设置字体注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是： 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组： 非代码类字体：Fallback 到 &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif 代码类字体： Fallback 到 consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, monospace 另外，每一项都有一个额外的 external 属性，此属性用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 配置示例 12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 设置代码高亮主题更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： 高亮主题设置示例 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 配置示例 12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 配置示例 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 友情链接编辑 主题配置文件 添加： 友情链接配置示例 12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 配置示例 1since: 2013 订阅微信公众号注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 在每篇文章的末尾显示微信公众号二维码，扫一扫，轻松订阅博客。 在微信公众号平台下载您的二维码，并将它存放于博客source/uploads/目录下。 然后编辑 主题配置文件，如下： 配置示例 12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /uploads/wechat-qcode.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 评论系统来必力登陆 来必力 获取你的 LiveRe UID。 编辑 主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 数据统计与分析百度统计 登录 百度统计，定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id 编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 内容分享服务百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true。 百度内容分享服务配置示例 1234# 百度分享服务baidushare: type: slide baidushare: true 搜索服务Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 然后粘贴刚才复制的代码到 1themes/next/layout/_layout.swig 文件中(放在 1&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 的下面)，并把href改为你的github地址 在网站底部加上访问量打开\themes\next\layout\_partials\footer.swig文件，在文件最前面加上以下代码： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码 代码如下： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 实现统计功能实现效果图 具体实现方法在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 部署到github pages在github新建GitHub Pages项目，具体步骤自行百度。 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 编辑 站点配置文件，添加/修改字段 deploy，配置如下： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] //提交信息 部署更新到github 1hexo g -d 访问https://temp.github.io/，temp为你的github用户名，即可查看博客页面。]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客建站</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo部署到git报错问题]]></title>
    <url>%2F2018%2F10%2F23%2F%E8%A7%A3%E5%86%B3Hexo%E9%83%A8%E7%BD%B2%E5%88%B0git%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用hexo deploy自动部署到github page的时候出现如下错误： 1fatal: could not read Username for &apos;https://github.com&apos;: Invalid argument 具体解决方法如下： Hexo配置要使用自动部署首先要安装hexo-deployer-git工具： 1npm install hexo-deployer-git --save 配置_config.yml中的deploy： 12345deploy: type: git repo: git@github.com:your_github_user_name/your_github_user_name.github.io.git branch: master message: 提交信息 生成ssh key命令行输入： 1$ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址） 接着出现的一些步骤都可以回车跳过，如下： 配置github账号的ssh key打开id_rsa.pub文件将一整串公钥拷贝下来 进入你的github账户设置，在ssh and GPG keys中新增一个ssh key 验证ssh key： 1ssh -T git@github.com 出现下面的语句说明你的ssh key已经配置好了 1Hi wispyoureyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 初始化本地仓库设置Git的user name和email： 12$ git config --global user.name &quot;wuyanqina&quot;$ git config --global user.email &quot;greenovia@qq.com&quot;（换成你的邮箱地址） 在本地的hexo init生成的文件夹中初始化git仓库： 1$ git init 将本地仓库和远程仓库连接（这一步骤可以不做）： 1$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了 网站部署12hexo cleanhexo g -d 这样你的博客就部署到了page上了~]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用操作]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo前要先安装Node.js和Git，具体安装请各自百度。 Hexo安装npm install -g hexo-cli 建站123hexo init &lt;folder&gt;(不写默认在当前目录)cd &lt;folder&gt;npm install 建站完成后目录结构├── _config.yml(网站的配置信息) ├── package.json(应用程序的信息) ├── scaffolds(模板文件夹) ├── source(资源文件夹) | ├── _drafts(草稿文件夹) | └── _posts(文章文件夹) └── themes(Hexo主题) 新建文章12345hexo new [layout] &lt;title&gt;布局 路径post source/_postspage sourcedraft source/_drafts layout对应于scaffolds文件夹中布局文件;默认取_config.yml中的default_layout Hexo服务器安装1npm install hexo-server --save 启动服务器12hexo server(默认4000)或hexo server -p 5000(指定端口)hexo s --debug 生成静态文件并部署网站hexo generate --deploy 简写：hexo g -d git配置安装 hexo-deployer-git。 $ npm install hexo-deployer-git --save deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] //提交信息 参考资料Hexo中文文档]]></content>
      <categories>
        <category>博客建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NXOpen包装ufunc]]></title>
    <url>%2F2017%2F08%2F05%2FNXOpen%E5%8C%85%E8%A3%85ufunc%2F</url>
    <content type="text"><![CDATA[NXOpen是一个应用程序编程接口（API）工具包的集合，它允许通过开放的体系结构灵活地集成定制NX应用程序。其目的是使复杂和重复的任务自动化。此外，还允许集成不同的应用程序，以及第三方和NX应用程序，在不同的计算机平台上共享数据，从不同的位置使用异构网络，甚至跨Internet。NXOpen API提供了一个开放的体系结构，可以由第三方、客户和内部用户利用它们来创建和集成定制软件应用程序。NXOpen主要是指NX的common API。 ufunc(Open C)发展了很多年，包含5000多个函数，功能覆盖方方面面。Common API通过生成.NET、Java和Python的包装类来保证能使用这些函数。 一些OpenC函数没有包装类，详情参见列表Non-NXOpen functionsOpenC模块及函数映射到NXOpen详见命名约定 Common API将对象表示为典型的面向对象对象，而OpenC则将它们表示为标记(Tag)。下面的示例说明如何在对象和标记之间切换。 在使用包装类前要理解一些简单的概念： 名称空间和模块结构.NET NXOpen 包装类定义在NXOpen.UF命名空间。Java包装类在NXOpenUF.jar中，定义在nxopen.uf包。Python包装类包含在NXOpen_UF.pvd扩展模块，定义在NXOpen.UF模块。 UFSession获得包装类之前你首先要获得UFSession的实例。包装类(与ufunc模块对应)定义在UFSession的方法中。例如：UFSession的curve()方法返回一个UFCurve类的实例。 TaggedObjectManager and NXObjectManagerTaggedObjectManager是定义在nxopen包里面的一个NXOpen Java接口。使用该类的get方法获取与标签对应的NXOpen Tag对象。.NET、Python对应的类分别为TaggedObjectManager、NXObjectManager。 Tag属性所有的NXOpen标签对象在.NET和Python中都有一个Tag属性，在Java和c++中有一个tag()方法。 包装类-具体实例1.NXopen .NET下面的例子使用ufunc API生成一个圆弧并用NXOpen.NET API查询圆弧数据：1234567891011121314151617Dim theSession As Session = Session.GetSession() Dim theUFSession As UFSession = UFSession.GetUFSession() &apos; Create an ARC using the Open API Tag arc;Dim arc_coords As UFCurve.Arcarc_coords.radius = 1.0arc_coords.arc_center = New Double()&#123;1.0, 1.0, 0.0&#125;arc_coords.start_angle = 0.0arc_coords.end_angle = Math.PIarc_coords.matrix_tag = theSession.Parts.Display.WCS.CoordinateSystem.Orientation.TagtheUFSession.Curve.CreateArc( arc_coords, arc)&apos; Get the Arc Object to use with NX Open NXOpen.Arc nxArc= CType(NXOpen.Utilities.NXObjectManager.Get(arc), NXOpen.Arc)&apos;Get the Arc parameters using NX Open APIsDim start_angle As Double = nxArc.StartAngle Dim end_angle As Double = nxArc.EndAngle Dim arc_center As NXOpen.Point3d = nxArc.CenterPoint 2.NXOpen JAVA下面的例子使用ufunc API生成一个圆弧并用NXOpenJava API查询圆弧数据：12345678910111213141516171819202122Session theSession = (Session)SessionFactory.get(&quot;Session&quot;);UFSession theUFSession = (UFSession)SessionFactory.get(&quot;UFSession&quot;);/* Create Arc using Open C API wrapper */UFCurve ufCurve = theUFSession.curve();UFCurve.Arc ufArc = new UFCurve.Arc();UFCsys ufCsys = theUFSession.csys();/* Fill out the data structure */ufArc.startAngle = 0.0;ufArc.endAngle = 3.0;ufArc.arcCenter=new double[3];ufArc.arcCenter[0] = 0.0;ufArc.arcCenter[1] = 0.0;ufArc.arcCenter[2] = 1.0;ufArc.radius = 2.0;/* Create Arc */Tag wcsData = ufCsys.askWcs();ufArc.matrixTag = ufCsys.askMatrixOfObject(wcsData);Tag arcTag = ufCurve.createArc(ufArc);/* Get the Arc Object to use with NX Open*/Arc arc = (Arc)theSession.taggedObjectManager().get(arc2Tag);/* Get arc parameters using NX Open Java APIs */double start_angle = arc.startAngle(); 3.NXOpen Python下面的例子使用ufunc API生成一个圆弧并用NXOpenPython API查询圆弧数据：1234567891011121314151617theSession = NXOpen.Session.GetSession() theUFSession = NXOpen.UF.UFSession.GetUFSession() # Create an ARC using the Open API arc_coords = NXOpen.UF.Curve.Arc()arc_coords.Radius = 1.0arc_coords.ArcCenter = [1.0, 1.0, 0.0]arc_coords.StartAngle = 0.0arc_coords.EndAngle = math.piarc_coords.MatrixTag = theSession.Parts.Display.WCS.CoordinateSystem.Orientation.Tagarc_tag = theUFSession.Curve.CreateArc( arc_coords)# Get the Arc Object to use with NX Open nxArc = NXOpen.TaggedObjectManager.GetTaggedObject(arc_tag)# Get the Arc parameters using NX Open APIsstart_angle = nxArc.StartAngle end_angle = nxArc.EndAngle arc_center = nxArc.CenterPoint 参考资料包装类官方文档]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NXOpen应用程序目录结构]]></title>
    <url>%2F2017%2F08%2F03%2FNXOpen%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[对于环境变量指定的任何根目录，NX寻找以下五个子目录：startup, application, udo, udf, and dfa。 注意：子目录下的文件名不能跟根目录下任何目录名相同(包含根目录下的所有子目录，不管层级)。否则程序执行会报错。 每个子目录使用说明如下： 子目录 使用 startup 放置自定义菜单文件、对话框和可执行文件。通常用于一般功能的应用程序 application 放置与NX菜单关联的自定义菜单项和可执行文件 udo 放置NX初始化时用于管理自定义对象所注册的方法 dfa 放置与该应用程序关联的类、函数和方法的KF ASCII定义文件。此目录不显示在DFA管理器或KF首选项中 udf 用户的自定义特性 有关使用环境变量和客户默认配置KF应用程序的信息。请参见知识融合在线帮助中的默认值和变量概述。 当启动NX时，它会自动加载startup和udo目录下的库和菜单文件。当NX加载每个共享库时，它立即执行标准入口点（参见入口点）。然后应用程序可以初始化任何事件。 为了让NX更快地启动，可以将程序放在application目录中，而不是startup目录。当您选择此策略时，当用户选择关联菜单按钮时，NX加载库，而不是在启动时加载。这个策略不能用于管理UDO。UDO程序必须放在startup，以确保NX能加载到事件。 包含在这些子目录的动态加载共享库必须包含操作系统的正确文件扩展名。如果没有使用正确的扩展，则NX将无法找到目标文件。NX将显示一个错误，指出应用程序没有被正确注册。 参考资料NXopen应用程序目录结构]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX新建工具条]]></title>
    <url>%2F2017%2F08%2F01%2FNX%E6%96%B0%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[NX工具条包括经典工具条和新版本的功能区。两种对应于不同的文件。经典工具条是以.tbr结尾的文件，功能区为.rtb结尾。 工具条文件需放在应用程序startup文件夹，以确保NX启动时能找到该文件。整个应用要想被NX找到需配置环境变量UGII_USER_DIR=&lt;根路径&gt;。或在&lt;NX安装目录&gt;\UGII\menus\custom_dirs.dat文件中配置根路径。 经典工具条1234567891011121314TITLE 金旅二次开发工具VERSION 160DOCK TOP BUTTON MENU1 BUTTON MENU2 BUTTON MENU3 SEPARATOR BUTTON MENU21 BUTTON MENU22 SEPARATOR BUTTON TC1 SEPARATOR BUTTON DRAFT1 效果如下： TITLE顾名思义为标题 VERSION，版本 DOCK，工具栏的停靠位置。可去TOP、BOTTOM、LEFT、RIGHT等 BUTTON后为men文件中定义的菜单项名称。如果菜单项有定义图标，则显示图标。否则显示菜单项文字。 SEPARATOR，分割线 新版本功能区1234567891011121314151617181920212223242526272829TITLE 金旅二次开发工具VERSION 170BEGIN_GROUP JL_MAIN1LABEL 金旅二次开发工具 BUTTON MENU1 BUTTON MENU2 BUTTON MENU3END_GROUPBEGIN_GROUP JL_MAIN2LABEL 自动指引 BUTTON MENU21 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXT BUTTON MENU22 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUPBEGIN_GROUP JL_TCLABEL TC相关 BUTTON TC1 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUPBEGIN_GROUP JL_DRAFTLABEL 制图相关 BUTTON DRAFT1 RIBBON_STYLE ALWAYS_SMALL_IMAGE_AND_TEXTEND_GROUP 效果如下： TITLE，标题 VERSION，版本 BEGIN_GROUP，END_GROUP定义一个组。如上图有”金旅二次开发工具”、”自动指引”、”TC相关”、”制图相关”四个组。 LABEL，组名称 BUTTON，men文件中菜单项的名称 RIBBON_STYLE，按钮的样式 参考资料细节请参考菜单及工具条]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX新建菜单栏]]></title>
    <url>%2F2017%2F07%2F30%2FNX%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[Menuscript语言可将新菜单项添加到NX。Menuscript命令存在于.men后缀结尾的文件中。无论使用哪种语言，菜单文件都是相同的。 要添加一个新的菜单项，以下描述菜单文件的基本命令：1234567VERSION 120 EDIT UG_GATEWAY_MAIN_MENUBAR MENU &lt;独一无二的文本，用于识别现有的或新的菜单&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; &lt;...&gt; END_OF_MENU 每个菜单项可以通过下面的命令定义：12345BUTTON &lt;所有菜单项独一无二的文本&gt; LABEL &lt;菜单展示的文本&gt; MESSAGE &lt;鼠标放在按钮上弹出的提示&gt;BITMAP &lt;按钮图标名称&gt;ACTIONS &lt;程序的名称&gt; 任何程序都可以链接到菜单文件中的一个按钮。可以是与NX无关的浏览器，或是传统的NX程序。men文件一定要放在startup目录下 运行与NX无关的程序下面简单的men文件在打开菜单后面注册一个按钮，通过IE访问西门子官网。1234567VERSION 120 EDIT UG_GATEWAY_MAIN_MENUBAR AFTER UG_FILE_OPEN BUTTON SAMPLE_GO_TO_SIEMENS LABEL Go to Siemens.com ACTIONS &quot;start iexplore http://www.siemens.com&quot; END_OF_AFTER 运行与CommonAPI程序如果想从按钮运行一个通用的API程序，必须要把编译后的程序放置在application目录下。在men文件中的ACTIONS后加上文件名。对于C、C++、C#或VB程序，不需带后缀。对于java程序，需带后缀让NX知道是.class或.jar文件。12345678910111213141516171819202122232425VERSION 120EDIT UG_GATEWAY_MAIN_MENUBARAFTER UG_HELP CASCADE_BUTTON MY_MENU LABEL 二次开发工具END_OF_AFTERMENU MY_MENU BUTTON MENU1 LABEL 属性快捷填写 MESSAGE 快速填写属性 BITMAP properties_object ACTIONS FillInProperty.jar SEPARATOR BUTTON MENU2 LABEL 自动分层 MESSAGE 将显示的实体、草图、曲线点、基准、片体移动到指定层，2、3层对象忽略，除了1（有用实体）、2（有用片体）、3（有用控制曲线）层打开，其他隐藏 BITMAP layer_move_to ACTIONS Layout.classEND_OF_MENU 参考资料细节请参考菜单及工具条]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[官方例子：怎样创建一个NXOpen程序]]></title>
    <url>%2F2017%2F07%2F27%2F%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AANXOpen%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[你可以为许多不同的任务和函数创建一个NX打开的程序，比如在NX中操作的一个从命令行启动的函数，它可以被添加到菜单列表或其他NX命令结构中，或者是一个新对话框。 在这个例子中，我们创建一个对话框，选择面然后改变面颜色。 主要步骤如下:12345创建一个对话框从对话框中生成代码添加代码到生成的源文件中设置目录结构测试 在这个例子中，我们修改initialize(初始化)和apply(应用)回调函数。对于更复杂的对话框，你可以将代码添加到update(更新)回调函数来处理不断的变化。有关创建对话框的其他信息，参见UIStyler块介绍。有关使用静态API属性的信息，参见块属性的静态API 一、创建对话框1.打开NX 2.打开建模应用模块。可以通过打开一个零件或新建一个模型进入 3.搜索“块 UI 样式编辑器”进入UI编辑器(注意搜索要带空格) 4.在块目录组中，打开‘选择’目录。点击‘选择对象’，创建并显示“无标题”对话框 5.打开‘基本’目录，点击‘对象颜色拾取器’ 6.通过修改对话框中的属性来更改对话框标签。 在块选项卡，group块树中选择selection0。在属性选项卡，选择LabelString。双击修改为”选择面” 选择SelectMode，右击将值从Single改Multiple 在树列表中选择colorPicker0。在属性选项卡，选择Label。双击修改为”选择颜色” 在树列表中选择Group。在属性选项卡，选择Label。双击修改为”面” 在树列表中选择Dialog。在属性选项卡，选择Label。双击修改为”改变面的颜色” 二、从对话框生成代码1.在设计对话框选择”代码生成”块，右击”语言”，选择Java 2.右击”生成附注”，选择True 3.右击”特定于块的代码”，选择True 4.确保”用户出口”为True。 5.确保”更新”、”确定”、”显示的对话框”为True 6.选择保存(ctrl+s)，生成一个.dlx文件,一个.java文件 7.点击”退出块 UI 样式编辑器” 三、向生成代码中添加代码1.打开.java 文件 2.添加”添加以下代码”、”添加代码结束”中间代码1234567891011121314151617public void initialize() throws NXException, RemoteException&#123; try &#123; group0 = (nxopen.blockstyler.Group)theDialog.topBlock().findBlock(&quot;group0&quot;); selection0 = (nxopen.blockstyler.SelectObject)theDialog.topBlock().findBlock(&quot;selection0&quot;); colorPicker0 = (nxopen.blockstyler.ObjectColorPicker)theDialog.topBlock().findBlock(&quot;colorPicker0&quot;); //添加以下代码--------------- selection0.addFilter(nxopen.blockstyler.SelectObject.FilterType.FACES);//过滤器，只能选择面 //添加代码结束--------------- &#125; catch(Exception ex) &#123; //---- Enter your exception handling code here ----- theUI.nxmessageBox().show(&quot;Block Styler&quot;, nxopen.NXMessageBox.DialogType.ERROR, ex.getMessage()); &#125;&#125; 12345678910111213141516171819202122232425262728293031public int apply() throws NXException, RemoteException&#123; int errorCode = 0; try &#123; //---- Enter your callback code here ----- //添加以下代码--------------- //获取DisplayModification对象 TaggedObject[] selObjs = selection0.getSelectedObjects(); DisplayModification dispMod = theSession.displayManager().newDisplayModification(); //获取选择的颜色 int[] colors = colorPicker0.getValue(); dispMod.setNewColor(colors[0]); //获取选择的面 List&lt;DisplayableObject&gt; dispObjs = new ArrayList&lt;DisplayableObject&gt;(); for (TaggedObject taggedObject : selObjs) &#123; dispObjs.add((DisplayableObject) taggedObject); &#125; //应用 dispMod.apply((DisplayableObject[]) dispObjs.toArray()); dispMod.dispose(); //添加代码结束--------------- &#125; catch(Exception ex) &#123; //---- Enter your exception handling code here ----- errorCode = 1; theUI.nxmessageBox().show(&quot;Block Styler&quot;, nxopen.NXMessageBox.DialogType.ERROR, ex.getMessage()); &#125; return errorCode;&#125; 四、设置目录结构1.设置以下环境变量作为应用程序的根目录。 UGII_USER_DIR(或UGII_GROUP_DIR)=&lt;full directory path&gt; 注意：此环境变量仅适用于单个应用程序。有关为单个或多个应用程序设置根目录的附加信息，请参见环境变量。 2.在上面指定的根目录下创建应用程序的目录结构。请参见应用程序目录结构，看看如何设置目录结构以及NX如何在启动时加载自定义文件和应用程序。 3.复制.class、.dlx文件到上一步中创建的应用程序目录 五、测试1.打开模型应用模块(打开或新建一个模型) 2.点击 文件–执行–NXOpen。快捷键Ctrl+U。选择.class文件运行 六、实例文件对话框文件：changeFaceColor.dlx源码：changeFaceColor.java]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈NX二次开发可用的开发工具包]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%B5%85%E8%B0%88NX%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%8F%AF%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[NX和其他西门子PLM软件产品提供了许多软件工具包。NXOpen是指提供直接与NX对象模型一起工作的过程API。每个API支持特定的编程语言。一组相对较新的语言都共享一个共同的对象模型，称为通用的API(Common API)。其他三种API已经存在多年，统称为遗留或经典API(Classic APIs)。 一、Common API这个NX架构向NX开发人员提供一个公共对象的特性和功能。使用这个公共对象模型，可以自动生成多语言绑定。这意味着来自通用api的所有语言都具有相同的对象集、对象属性和方法。此外，对于所有公共API，类层次结构是相同的。 这种体系结构比传统api使用的体系结构有许多优势。例如: 所有通用api语言在NX功能方面都是平等的。这意味着您可以自由地选择适合您特定需求的实现语言，而不必担心缺少的功能。 在NX中引入新的功能和自动化功能；交互方式和编程方式之间的功能不再延迟。 现在您可以访问NX开发人员使用的同一个对象模型。 通用api可以使用以下语言绑定： 1.NX Open for .NET - 这个API使用微软的.NET框架。这个API可以使用.NET兼容的语言创建任何自动化程序，包括Visual Basic .NET和C #。用户可以充分利用.NET框架提供的所有好处，包括本地Windows对话框开发工具和VisualStudio集成开发环境（IDE）的所有功能。如果Windows是你选择的平台，这个API是理想的。 2.NX Open for Java - 这个API使用甲骨文的java平台。java提供了许多好处，包括平台独立性和巨大的现有类库。java抽象窗口工具包（AWT）和Swing提供了工具构建平台无关的对话框。java远程方法调用（RMI）方法提供的工具来构建基于客户机/服务器应用程序。此外，还可以提供诸如Eclipse这样的免费开发环境。如果正在开发多个平台客户机/服务器应用程序，则此API是理想的。 3.NX Open for C++ - 这个API提供了NX的C++接口。这个新的C++库兼容Open C and Open C++ APIs。如果你需要提高现有的C / C++应用程序，这个API是理想的。 4.NX Open for Python - 这个API提供了一个NX的Python接口。Python是一种脚本语言，它使用现代编程范式，如面向对象编程和反射。它使用较简介的语法，并有一些用于科学和数值编程的扩展包。没有提供Python的远程API。 二、Journaling(录制功能)虽然Journaling不是一个工具包，在这里介绍是因为它可以用来记录自动化解决方案或使用大型应用程序生成代码。 Journaling是一种快速的自动化工具，记录、编辑和回放，交互式NX。它从通用API构建，在NX的交互式会话生成一个脚本文件，它可以在稍后时间重放。这些Journaling可以通过简单的编程结构和用户界面组件进行编辑和增强，以快速生成定制程序。 虽然日志重播目前仅限于# Python，C，Visual Basic .NET，用户可以选择记录在任何常用的API的语言。这种技术可以用来生成示例代码，然后可以在较大的应用程序中使用。 三、Classic APIs在NX采用通用api之前，开发了这三个api。这些API仍然可用，但不再对它们增强。 1.Open C - Open C API(ufunc)是NX的直接编程接口，它允许用户使用流行的C编程语言创建自定义应用程序。NX开发人员、客户和合作伙伴已经使用它来生成独特的应用程序来增强NX或充当完全独立的实用程序。Open C还提供了一个完全可扩展的数据模型，允许客户定义类似于标准NX对象的新类型的对象，并持久保存在NX部分文件中。Open C API已经发展了很多年，由5000多个函数组成。这些函数统称为用户函数。这个API通常被称为ufunc。开放的C函数通常有命名约定：UF__。例如，uf_modl_create_plane()。考虑到这个API的历史，它提供了广泛的功能。为了确保新的应用程序都可以访问这些功能.net，java，Python提供了包装器。 2.Open C++ - 这个API为NX提供了第一个面向对象的接口。用C++写的，这个API充分利用了面向对象的特征包括继承、封装和多态性。OpenC++提供完整的访问的类层次结构，使客户能够重写方法，派生自己的类，并创建全新NX的持久对象。OpenC++完全兼容Open C API。 3.NX Open GRIP - GRIP(图形交互编程)是一种用于自动化CAD/CAM任务的中间脚本语言。用户可以创建应用程序来实现数控操作，创建几何和绘图对象，控制系统参数，执行文件管理功能和修改现有的几何图形。 四、KF(Knowledge Fusion)Knowledge Fusion (KF) - 此API是嵌入在NX中的解释型、面向对象的语言。KF允许您通过创建规则，将工程知识添加到任务中，这些规则是语言的基本组成部分。语言是声明性的，而不是过程性的，这意味着规则在需要时执行，不管顺序如何。知识融合规则引擎根据规则之间的依赖关系确定正确的规则触发序列。此外，该语言还具有访问外部知识库（如数据库或电子表格）的能力，以及与其他应用程序（如分析和优化包）的接口。此API非常适合于需要参与模型更新的关联、持久对象的应用程序。有关更多信息，请参见知识融合和知识融合帮助和最佳实践。 五、其他的NX开发工具包除了上面提供的NX开放API工具包之外，西门子PLM软件还提供了以下的NX自动化工具。本文档将大致介绍NX开放的这些工具包。每个工具箱的完整信息可以在各自的用户指南中找到。 1.Block Styler (UI Styler) - 这是一个视觉用户界面生成器，可以交互设计的便携式NX风格对话框。它由NX开发人员在内部使用，外部由用户和第三方开发人员使用。这提供了一个运行在NX内的对话框生成器。由生成器产生的对话框定义文件是在运行NX会话期间自动加载，并提供程序处理用户交互的必要事件回调。更多信息见BlockStyler用户指南。 2.MenuScript - 此工具允许终端用户和第三方开发人员创建和编辑NX菜单。MenuScript是一个文本语言，可以用来自定义NX菜单项,用于从NX启动应用程序。菜单文件支持定制的主菜单栏和快速查看弹出菜单。标准的NX菜单可以定制,以满足特定的工作流程,可添加Block Styler创建对话框到新的菜单项。更多信息请查看菜单用户指南。 3.Open User Interface Styler (UI Styler) - UI Styler是可视化的用户界面生成器，用于维护Block Styler之前创建的基于UI Styler的对话框。新的对话框，应使用Block Styler.定义。更多信息见UI Styler用户指南。 六、其他的西门子PLM软件工具包西门子PLM软件提供了许多其他自动化和系统集成工具包。这里提到了两个工具包，因为它们与NX一起使用的频率比较高。这些工具包的使用超出了本手册的范围。有关更多信息，请参见它们各自的用户指南，它们不是NX帮助库的一部分。 1.Parasolid - Parasolid是世界领先的生产验证的几何建模软件，允许用户模拟行业最复杂的部件和组件。作为在不同计算机上的几何引擎的辅助设计、制造和工程（CAD/CAM/CAE）应用，Parasolid已在全球产品设计建立一个行业标准。Parasolid是用NX实体建模内核。 2.Teamcenter Engineering Integration Tool Kit (ITK) - 这个API提供用于定制Teamcenter支持组织的特定的数据管理功能和公用事业的需求。Teamcenter是客户端-服务器架构为基础的系统。可以对服务器和客户机部分进行定制。如果必须直接与Teamcenter自动化保存或检索产品数据通过NX和其他第三方应用程序生成过程中的应用，那么这个API是理想的。 参考资料官方例子链接：UFUN中文API 密码：pjc1链接：NXJavaAPI离线文档 密码：494sJava官方API 推荐网站nxjournaling]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NX二次开发Eclipse环境搭建]]></title>
    <url>%2F2017%2F07%2F20%2FNX%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91Eclipse%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器；本文章适用于使用Java进行NX二次开发。其他NXopen支持的语言请参考官方文档。 一、开发环境的搭建NXjar包存放目录：%NX安装目录%\NXBIN。NX提供的所有jar包，导入NXOpen开头的jar到JavaProject即可 二、调试环境的搭建使用Eclipse调试Java程序： 1.在NX中，选择 文件→执行 →替代Java参数 2.在替代Java参数对话框, UGII_JVM_OPTIONS 输入框中输入: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8888 (可选) 在 UGII_JVM_CLASSPATH 对话框中, 填入任意额外的Java classpath地址 3.你不需要在这里写入NXopen jar的classpath，因为他们会被NX自动加载 4.(可选) 在 UGII_JVM_LIBRARY_DIR 对话框, 写入你的64位Java的JVM地址。例如: %jre安装目录%\bin\server 5.点击 确定 6.在Eclipse Package Explorer，右键项目，Debug As →Debug Configurations 7.创建一个Remote Java Application，使用和上面相同的端口 8.你需要在NX上运行Java程序。Eclipse会在指定断点暂停 9.其他语言调试环境搭建敬请参见NX其他语言调试环境搭建 THE END.]]></content>
      <categories>
        <category>NX二次开发</category>
      </categories>
      <tags>
        <tag>NX二次开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
